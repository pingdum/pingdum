import { useEffect, useRef, useState } from 'react'

type GeolocationState = {
  loading: boolean
  accuracy: number | null
  altitude: number | null
  altitudeAccuracy: number | null
  heading: number | null
  latitude: number | null
  longitude: number | null
  speed: number | null
  timestamp: number | null
  permission: PermissionState | null // 'granted' | 'denied' | 'prompt'
  error: GeolocationPositionError | null
}

export function useGeolocation(options: PositionOptions = {}): GeolocationState {
  const [state, setState] = useState<GeolocationState>({
    loading: true,
    accuracy: null,
    altitude: null,
    altitudeAccuracy: null,
    heading: null,
    latitude: null,
    longitude: null,
    speed: null,
    timestamp: null,
    permission: null,
    error: null
  })

  const optionsRef = useRef(options)

  useEffect(() => {
    if (!('geolocation' in navigator)) {
      setState((s) => ({
        ...s,
        loading: false,
        permission: 'denied',
        error: {
          code: 0,
          message: 'Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Geolocation.',
          PERMISSION_DENIED: 1,
          POSITION_UNAVAILABLE: 2,
          TIMEOUT: 3
        } as GeolocationPositionError
      }))
      return
    }

    const requestLocation = () => {
      const onEvent = (position: GeolocationPosition) => {
        const { coords, timestamp } = position
        setState({
          loading: false,
          timestamp,
          latitude: coords.latitude,
          longitude: coords.longitude,
          altitude: coords.altitude,
          accuracy: coords.accuracy,
          altitudeAccuracy: coords.altitudeAccuracy,
          heading: coords.heading,
          speed: coords.speed,
          permission: 'granted',
          error: null
        })
      }

      const onEventError = (error: GeolocationPositionError) => {
        setState((s) => ({
          ...s,
          loading: false,
          permission: error.code === error.PERMISSION_DENIED ? 'denied' : s.permission,
          error
        }))
      }

      // G·ªçi ƒë·ªÉ hi·ªÉn th·ªã prompt (n·∫øu ch∆∞a c√≥ quy·ªÅn)
      navigator.geolocation.getCurrentPosition(onEvent, onEventError, optionsRef.current)

      // Theo d√µi v·ªã tr√≠ li√™n t·ª•c
      const watchId = navigator.geolocation.watchPosition(onEvent, onEventError, optionsRef.current)

      return () => navigator.geolocation.clearWatch(watchId)
    }

    // üîπ Ki·ªÉm tra quy·ªÅn tr∆∞·ªõc
    if ('permissions' in navigator) {
      navigator.permissions
        .query({ name: 'geolocation' })
        .then((result) => {
          setState((s) => ({ ...s, permission: result.state }))

          if (result.state === 'granted' || result.state === 'prompt') {
            // N·∫øu ƒë√£ ƒë∆∞·ª£c c·∫•p ho·∫∑c ch∆∞a bao gi·ªù c·∫•p (prompt) ‚Üí g·ªçi ƒë·ªÉ hi·ªÉn th·ªã prompt
            requestLocation()
          } else if (result.state === 'denied') {
            setState((s) => ({
              ...s,
              loading: false,
              permission: 'denied',
              error: {
                code: 1,
                message: 'Ng∆∞·ªùi d√πng ƒë√£ t·ª´ ch·ªëi quy·ªÅn truy c·∫≠p v·ªã tr√≠.',
                PERMISSION_DENIED: 1,
                POSITION_UNAVAILABLE: 2,
                TIMEOUT: 3
              } as GeolocationPositionError
            }))
          }

          // L·∫Øng nghe khi quy·ªÅn thay ƒë·ªïi
          result.onchange = () => {
            setState((s) => ({ ...s, permission: result.state }))
            if (result.state === 'granted') requestLocation()
          }
        })
        .catch(() => {
          // Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Permissions API
          requestLocation()
        })
    } else {
      // Kh√¥ng c√≥ Permissions API ‚Üí c·ª© g·ªçi lu√¥n
      requestLocation()
    }
  }, [])

  return state
}
